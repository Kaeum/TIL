# 이펙티브자바 2장 - 객체 생성과 파괴

## 아이템8 finalizer와 cleaner 사용을 피하라

자바가 제공하는 두 가지 소멸자(finalizer, cleaner)는 예측할 수 없고, 느리고, 쓰지 말아야 한다.
* finalizer와 cleaner는 즉시 수행된다는 보장이 없다. **따라서 제때 실행되어야 하는 작업을 할 수 없다.**
파일 닫기와 같은 작업을 finalizer/cleaner에 맡기면 큰 오류가 발생할 수도 있다. 시스템이 열 수 있는 파일 개수에 한계가 있는데, 두 소멸자의 실행을 게을리해서 새 파일을 열지 못한다면 프로그램 실패로 이어질 수 있다. 실제로 현업에서 finalizer 실행이 지연됨으로써 문제를 일으킨다. (예를 들어, 수천 개의 객체가 finalizer 대기열에서 회수되기만을 기다리다가 `OutOfMemoryError`를 일으키는 경우가 있다. finalizer 스레드는 다른 애플리케이션 스레드보다 우선순위가 낮기 때문.) 자바 언어 명세는 어떤 스레드가 finalizer를 수행할 지 명시하지 않으니(심지어는 수행 여부조차 보장하지 않는다고 한다), 유일한 해결책은 finalizer 사용을 피하는 것. cleaner의 경우 자신을 수행할 스레드를 제어할 수 있다는 면에서는 조금 낫다고 할 수 있으나, 즉각 수행되리라는 보장이 없다.
따라서, 프로그램 생애주기와 상관없으며 **상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.**

* finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다. 잡지 못한 예외 떄문에 해당 객체는 자칫 마무리가 덜 된 상태로 남을 수 있다. 보통의 경우엔 잡지 못한 예외가 스레드를 중단시키고 스택 추적 내역을 출력하겠지만, 같은 일이 finalizer에서 일어난다면 경고조차 출력하지 않는다. 그나마 cleaner의 경우는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않는다.

* finalizer/cleaner는 심각한 성능 문제도 동반한다.
* finalizer를 사용한 클래스는 finalizer 공격에 노출되어 잠재적 보안 문제도 있다.
* 그렇다면 cleaner와 finalizer는 대체 어디다 쓰는가?
    1. 클라이언트가 close 메서드를 호출하지 않을 경우를 대비한, 안전망 역할
    2. 네이티브 피어와 연결된 객체(예를들어, 윈도우 객체와 연결된 JFrame객체)는 GC가 존재를 알지 못하므로 finalizer/cleaner가 처리하기에 적합. 단, 성능 저하를 감당할 수 있는 경우에만!
* 그렇다면 대안은 무엇인가? **`AutoCloseable` + try-with-resources**